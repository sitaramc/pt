#!/usr/bin/perl
use strict;
use warnings;
use 5.10.0;
use IPC::Cmd qw[can_run run run_forked];
use File::Path qw(make_path);
use Data::Dumper;
use Cwd;

# use Time::HiRes qw(sleep);
# use POSIX ":sys_wait_h";

# ----------------------------------------------------------------------
# constants, globals, and option handling

my %dispatch = (
    new     =>  \&_new,
    git     =>  \&_git,
    tag     =>  \&_tag,
    tags    =>  \&_tags,
    log     =>  \&_log,
    list    =>  \&_list,
    l       =>  \&_list,
    show    =>  \&_show,
    s       =>  \&_show,
    history =>  \&_history,
    h       =>  \&_history,
    attach  =>  \&_attach,
    files   =>  \&_files,
    open    =>  \&_fopen,
    close   =>  \&_close,
    edit    =>  \&_edit,
    sync    =>  \&_sync,
);

@ARGV = qw(list) unless @ARGV;

# special cases
usage() if $ARGV[0] eq '-h' or $ARGV[0] eq 'help';
unshift @ARGV, 'list' if $ARGV[0] =~ m(^[/@-]);

my $wd = getcwd();
my $xo = $ENV{PROJECT_TRACKER_XDG_OPEN} || "xdg-open";
chdir($ENV{PROJECT_TRACKER_DIR} || "$ENV{HOME}/.project-tracker") or die "I can't find the project tracker data!\n";

my $cmd = shift;
die "Invalid command; run with '-h' to see usage" unless $dispatch{$cmd};

# ----------------------------------------------------------------------
# main

$dispatch{$cmd}->(@ARGV);

exit 0;

# ----------------------------------------------------------------------
# subcomands
sub _new {
    die "'new' needs a 'title'\n" unless @_;
    my $id = new_id();
    my $dir = Y() . "/$id";
    make_path( "$dir/tags" );

    say STDERR "created $id";
    _print("$dir/title", join(" ", @_) . "\n");
    _editor("$dir/details");
}

sub _git {
    exec("git", @ARGV);
}

sub _tag {
    die "this command needs an ID\n" unless @_;
    my ($id, $dir) = id_dir(+shift());

    while (@_) {
        my $tag = shift;
        warn("ignoring bad tag '$tag', please keep tags as simple words\n"), next if $tag =~ /[^\w@.:-]/;
        if ($tag =~ s/^-//) {
            unlink "$dir/tags/$tag";
            _log($id, "tag $tag removed");
        } else {
            _print("$dir/tags/$tag", "");    # "touch" file (no content; just filename)
            _log($id, "tag $tag added");
        }
    }
}

sub _tags {
    system("find . -name .git -prune -o -type d -name tags -print | xargs -l1 ls | LANG=C sort -u");
}

sub _log {
    die "this command needs an ID\n" unless @_;
    my ($id, $dir) = id_dir(+shift());
    die "'log' needs some text to log!\n" unless @_;
    dated_print("$dir/log", join(" ", "($ENV{USER})", @_));
}

sub _list {
    my @IDs = get_IDs(@_);

    start_pager();
    for my $id (sort @IDs) {
        my $dir;
        ($id, $dir) = id_dir($id);
        my $taglist = join(", ", map { s(.*/)(); $_ } sort glob("$dir/tags/*"));
        my @nfiles = glob("$dir/files/*");
        $taglist = "[" . scalar(@nfiles) . "] $taglist" if @nfiles;
        printf "%s | %-22s | %s", $id, $taglist, slurp("$dir/title");
    }
}

sub get_IDs {
    my %set;
    push @_, '-closed' unless grep { $_ eq 'closed' } @_;

    # seed the set with ALL items
    map {
        s(.*/)(); chomp; $set{$_} = 1
    } grep {
        m(/\d\d\d\d/)
    } `find . -name .git -prune -o -type d -print | grep -v -e tags -e files`;

    # get all the filenames under "tags"
    my $tags = `find . -name .git -prune -o -type f -print | grep /tags/`;

    while (@_) {
        my $rot = shift;     # regex or tag
        if ($rot =~ s(^/)()) {
            # positive regex
            my %IDs = map { $_ => 1 } grep_IDs($rot);
            for my $k (keys %set) {
                delete $set{$k} unless exists $IDs{$k};
            }
        } elsif ($rot =~ s(^-/)()) {
            # negative regex
            my %IDs = map { $_ => 1 } grep_IDs($rot);
            for my $k (keys %set) {
                delete $set{$k} if exists $IDs{$k};
            }
        } elsif ($rot =~ s/^-//) {
            # negative tag
            map {
                delete $set{$_} if $tags =~ m(/$_/tags/$rot$)m
            } sort keys %set;
        } else {
            # positive tag
            map {
                delete $set{$_} unless $tags =~ m(/$_/tags/$rot$)m
            } sort keys %set;
        }
    }

    my @IDs = sort grep { $set{$_} } keys %set;
    return @IDs;
}

sub grep_IDs {
    my $regex = shift;
    my @IDs;
    if ($regex =~ s(^/)()) {
        @IDs = `find . -maxdepth 3 -type f | grep -v ^./.git | xargs egrep -l -i '$regex' | cut -f3 -d/`;
    } else {
        @IDs = `find . -maxdepth 3 -type f -name title | xargs egrep -l -i '$regex' | cut -f3 -d/`;
    }
    chomp(@IDs);
    return @IDs;
}

sub _show {
    die "this command needs an ID\n" unless @_;
    my ($id, $dir) = id_dir(+shift());

    start_pager();
    my $taglist = join(", ", map { s(.*/)(); $_ } sort glob("$dir/tags/*"));
    printf "title:\t%stags:\t%s\n", slurp("$dir/title"), $taglist;
    printf "id:\t%s\n", $id;
    if (glob("$dir/files/*")) {
        print "files:\n";
        print "\t$_" for `ls -1 $dir/files`;
    }
    print "\n";
    print slurp("$dir/details");
    if (-f "$dir/log") {
        print "\n" . "-" x 80 . "\nLOG:\n";
        print slurp("$dir/log");
    }
    print "\n" . "=" x 80 . "\n";
}

sub _history {
    die "unlike 'list', 'history' *requires* a search term (/regex, //regex, or list of tags\n" unless @_;

    my @IDs = get_IDs(@_);

    start_pager();
    for my $id (sort @IDs) {
        my $dir;
        ($id, $dir) = id_dir($id);
        my $taglist = join(", ", map { s(.*/)(); $_ } sort glob("$dir/tags/*"));
        my @nfiles = glob("$dir/files/*");
        $taglist = "[" . scalar(@nfiles) . "] $taglist" if @nfiles;
        printf "%s | %-22s | %s", $id, $taglist, slurp("$dir/title");
        if (-f "$dir/log") {
            my $l = slurp("$dir/log");
            $l =~ s/^(?!\d\d\d\d-.*\n).*\n//mg;
            print $l;
        }
        print "\n";
    }
}

sub _attach {
    die "this command needs an ID\n" unless @_;
    my ($id, $dir) = id_dir(+shift());

    my $file = shift;
    $file = "$wd/$file" unless $file =~ m(^/);
    die "can't find/read file '$file'\n" unless -f "$file";

    make_path( "$dir/files" );
    system("cp '$file' $dir/files");
    _log($id, "file $file added");
}

sub _files {
    # TODO: find ALL files in system if no ID given
    die "this command needs an ID\n" unless @_;
    my ($id, $dir) = id_dir(+shift());
    system("ls -1 $dir/files");
}

sub _fopen {
    die "this command needs an ID\n" unless @_;
    my ($id, $dir) = id_dir(+shift());

    my $pfn = shift;   # could be partial file name
    my @files = glob("$dir/files/*$pfn*");
    die "no file matches '$pfn'\n" if @files < 1;
    die "more than one file matches '$pfn'\n" if @files > 1;
    (my $file = $files[0]) =~ s(.*/)();

    die "you have '$file' in your current directory; will not overwrite, sorry!\n" if -f "$wd/$file";
    system("cp '$dir/files/$file' '$wd'");
    system($xo, "$wd/$file");
}

sub _close {
    die "this command needs an ID\n" unless @_;
    my ($id, $dir) = id_dir(+shift());

    _tag($id, "closed");
}

sub _edit {
    die "this command needs an ID\n" unless @_;
    my ($id, $dir) = id_dir(+shift());

    _editor(map { "$dir/$_" } qw(title details log));
}

sub _sync {
    system("git add -A");
    system("git diff --cached --name-only | cut -f1,2 -d/ | sort -u | xargs -I % cat %/title | sort | git commit -F -");
    system("git pull");
    system("git push origin master");

    exit $? >> 8;
}

# ----------------------------------------------------------------------
# service routines

sub new_id {
    `uuidgen -t` =~ /^(........)-(....)-/;
    my $x = Ymd() . "-$1-$2";
    return $x;
}

sub id_dir {
    # find the id and return (id, dir) tuple
    my $partial_id = shift;

    if (length($partial_id) == 24) {
        # it's a full ID
        $partial_id =~ /^(\d\d\d\d)-/ or die "WHAT?";
        return ($partial_id, "$1/$partial_id");
    }

    my $matched = 0;
    my $dir = '';
    my $id = '';
    for my $d (glob("*")) {
        for my $f (glob("$d/*")) {
            next unless $f =~ m(^$d/\d\d\d\d-\d\d-\d\d-$partial_id);
            $matched++;
            $dir = $d;
            $id = $f;
        }
    }

    die "ID '$partial_id' not found\n" unless $matched;
    die "ID '$partial_id' had too many matches\n" unless $matched == 1;

    $id =~ s(^\d\d\d\d/)();
    return ($id, "$dir/$id");
}

sub _editor {
    unless (-f $_[0]) {
        _print($_[0], "# by: $ENV{USER}\n");
    }

    my $editor = "vi";
    $editor = "vim" if can_run("vim");
    $editor = $ENV{VISUAL} || $ENV{EDITOR} || $editor;

    system($editor, @_);
    exit $? >> 8;
}

sub dated_print {
    my ($file, $text) = @_;
    my $old = ''; $old = slurp($file) if -f $file;
    _print($file, $old . Ymd() . "\t$text\n");
}

sub _open {
    open( my $fh, $_[0], $_[1] ) or die "open $_[1] failed: $!\n";
    return $fh;
}

sub _print {
    my ( $file, @text ) = @_;
    my $fh = _open( ">", "$file" );
    print $fh @text;
    close($fh) or die "close $file failed: $! at ", (caller)[1], " line ", (caller)[2], "\n";
}

sub slurp {
    local $/ = undef;
    my $fh = _open( "<", $_[0] );
    return <$fh>;
}

sub Y {
    my ( $s, $m, $h, $D, $M, $Y ) = localtime();
    return sprintf "%04d", 1900 + $Y;
}
sub Ymd {
    my ( $s, $m, $h, $D, $M, $Y ) = localtime();
    # return sprintf "%04d-%02d-%02d %02d:%02d:%02d", 1900 + $Y, 1 + $M, $D, $h, $m, $s;
    return sprintf "%04d-%02d-%02d", 1900 + $Y, 1 + $M, $D;
}

# ----------------------------------------------------------------------
# usage

sub usage {
    start_pager();
    say <DATA>;
    exit 1;
}

END { close(STDOUT); }
sub start_pager {
    return unless -t STDOUT;
    $ENV{LESS} ||= "-F";
    $ENV{LESS} .= "F" unless $ENV{LESS} =~ /F/;
    open(STDOUT, "|-", $ENV{PAGER} || "less");
}

=for notes
    NOT YET IMPLEMENTED:
    pt log tag              # chronological log of all items containing tag
    pt log /regex           # same, but for items where title matches regex
=cut

__DATA__

Simple git-aware project tracker.  Each item (issue, note, whatever you want
to call it) has a 1-line "title" file, a free-form "details" file, and a
mostly free-form "log" file.  It also has zero or more "tags".  The tag
"closed" has a special meaning (which should be obvious).

Usage:
    pt new <title>          # also opens an editor to take "details"
    pt tag <ID> <tag>       # add a tag
    pt tag <ID> -<tag>      # remove a tag (note the "-" sign)
    pt tags                 # list of all tags ever used in system (to check typos!)
    pt log <ID> <text>      # append text to the "log" file of <ID>

    pt                      # same as 'pt list' without arguments
    pt list                 # list all open items
    pt list <arguments>     # see LIST MODE below
    pt show <ID>            # full details of one specific item
    pt history <regex|tags> # search terms as for list command, shows title and log
        (the above 3 commands can be abbreviated to 'l', 's', and 'h')

    pt attach <ID> <file>   # attach a file to item
    pt files <ID>           # list files attached to an item
    pt open <ID> <file>     # get file from item to current directory and open it
                            # (partial filenames are OK, but should be unique)

    pt close <ID>           # adds the "closed" tag
    pt edit <ID>            # opens editor on title, details, and log files
                            #   !! USE WITH CARE !!

    pt sync                 # add and commit local changes, pull, and push
    pt git <arguments>      # run any git command

NOTE on <ID>: You need not supply the full ID; just the first few characters
after the date should be fine (as much as is needed to establish uniqueness)

LIST MODE:
-   List mode with arguments has the following variants.  In all cases, unless
    the tag "closed" is supplied, only open items are listed.

    pt list /regex          # list items where regex matches in title
    pt list //regex         # same, but match in title, details, or log
    pt list tag1            # list items containing the tag

-   You can use any number of regexes and tags; they are all ANDed together.

-   You can also have negations; e.g., '-tag2' or '-/regex'.  As a final
    example, '/foo -//bar tag1 -tag2' lists items matching foo in the title,
    and *not* matching bar in the title, details, or log, and which contain
    tag1 and do not contain tag2.
